#!/usr/bin/env bash
#=====================================================================================
# METABASE SECURE BOOTSTRAP (Ubuntu 22.04/24.04) — one‑shot, idempotent installer (v1.0)
#-------------------------------------------------------------------------------------
# Hardened, resumable installer for running Metabase + PostgreSQL behind Caddy (auto‑HTTPS)
# on a fresh Ubuntu VM with security best practices:
#   • SSH hardening (keys‑only, optional custom port; safe migration)
#   • UFW (only SSH + 80/443), Fail2ban
#   • Unattended security updates
#   • AppArmor ensured
#   • Docker Engine + Compose
#   • Caddy reverse proxy w/ Let’s Encrypt
#   • Optional Basic Auth in front of Metabase (Caddy `basic_auth`, creds embedded)
#   • Optional CrowdSec IPS
#   • Reboot safety: ask you to confirm SSH access before rebooting
#
# Resumable & safe:
#   • Each step checkpointed in /var/lib/mb-bootstrap/steps
#   • Can be re-run anytime; only missing steps execute
#   • SSH migration keeps port 22 until you explicitly allow closing it
#
# Quick start
#   1) Copy this file to the server, edit CONFIG below (set DOMAIN/EMAIL, user/key).
#   2) Run as root:  bash ./metabase-secure-bootstrap.sh
#   3) If prompted for reboot, open a 2nd terminal, verify SSH access, then confirm.
#   4) After a reboot, run the same command again; it resumes automatically.
#
# After install
#   • Visit: https://<DOMAIN> — you’ll see (optional) Basic Auth first, then Metabase setup.
#     Set the admin user/password in the Metabase UI. SMTP in Metabase is optional but recommended.
#
#=====================================================================================
set -Eeuo pipefail
IFS=$'\n\t'

#------------------------------------
# CONFIG — EDIT ME
#------------------------------------
DOMAIN="example.com"              # REQUIRED: your public hostname (A/AAAA → server IP)
EMAIL="admin@example.com"         # REQUIRED: email for Let’s Encrypt and notices

# Optional: create a non-root sudo user and provision their SSH key
CREATE_NEW_USER=true
NEW_USER="deploy"
NEW_USER_SSH_PUBLIC_KEY=""        # paste your SSH pubkey here (ssh-ed25519 ...)

# SSH hardening
SSH_PORT=22                        # set to e.g. 2222 if desired
DISABLE_PASSWORD_AUTH=true         # enforce key-only auth
DISABLE_ROOT_SSH=true              # disable interactive root login
CLOSE_PORT_22_AFTER_MIGRATION=false

# Reboot behavior
REQUIRE_SSH_CONFIRM_BEFORE_REBOOT=true
AUTO_REBOOT=false
SSH_CONFIRM_PORT=""               # empty = use SSH_PORT in message

# Metabase settings
MB_VERSION="latest"               # or pin e.g. "v0.48.12"
TZ="Etc/UTC"
MB_DATA_DIR="/opt/metabase"
SITE_URL="https://$DOMAIN/"       # used by Metabase for links/emails

# Proxy protection (front door)
BASIC_AUTH_ENABLE=true
BASIC_AUTH_USER="admin"
BASIC_AUTH_PASSWORD="changeMe"    # if left default/empty, a strong random will be generated
BASIC_AUTH_SECRETS_FILE="/root/metabase_basic_auth.txt"  # saved with 600 perms

# Application database (PostgreSQL in Docker) for Metabase metadata
DB_NAME="metabase"
DB_USER="metabase"
DB_PASSWORD=""                    # leave empty to auto-generate strong password

# Optional protection layer (CrowdSec)
CROWDSEC_ENABLE=false

#------------------------------------
# END CONFIG
#------------------------------------

VERSION_TAG="1.0.0"
STATE_DIR="/var/lib/mb-bootstrap"
STEP_DIR="$STATE_DIR/steps"
LOG_FILE="$STATE_DIR/install.log"
mkdir -p "$STEP_DIR"

log()   { printf "[mb-bootstrap] %s\n" "$*" | tee -a "$LOG_FILE"; }
info()  { log "➡  $*"; }
success(){ log "✔  $*"; }
warn()  { log "!  $*"; }
fail()  { log "✖  $*"; }

require_root() { [[ ${EUID} -eq 0 ]] || { fail "Please run as root (use sudo)."; exit 1; }; }
step_done() { [[ -f "$STEP_DIR/$1.done" ]]; }
mark_done() { touch "$STEP_DIR/$1.done"; success "$2"; }

abort_if_placeholder_domain() {
  if [[ "$DOMAIN" == "example.com" || -z "$DOMAIN" ]]; then
    fail "DOMAIN is not set. Edit CONFIG at top of this script."; exit 1
  fi
  if [[ "$EMAIL" == "admin@example.com" || -z "$EMAIL" ]]; then
    fail "EMAIL is not set. Edit CONFIG at top of this script."; exit 1
  fi
}

random_base64() { openssl rand -base64 "$1" | tr -d '\n' | tr -d '=' | tr '+/' '-_'; }
random_hex()    { openssl rand -hex "$1"; }

bootstrap_packages() {
  apt-get update -y
  DEBIAN_FRONTEND=noninteractive apt-get install -y \
    apt-transport-https ca-certificates curl gnupg lsb-release jq \
    software-properties-common ufw fail2ban unzip dnsutils \
    apparmor apparmor-utils needrestart nano
}

check_dns() {
  local pub_ip a_ip
  pub_ip=$(curl -s https://api.ipify.org || true)
  a_ip=$(dig +short A "$DOMAIN" | tail -n1 || true)
  if [[ -z "$pub_ip" || -z "$a_ip" ]]; then warn "Skipping DNS check (no IP)"; return; fi
  if [[ "$a_ip" != "$pub_ip" ]]; then
    warn "DNS A for $DOMAIN is $a_ip, server public IP is $pub_ip — LE may fail until it matches."
  else
    success "DNS looks good ($DOMAIN → $a_ip)."
  fi
}

#-------------------------------------------------------------------------------------
# STEP 00: Preflight
#-------------------------------------------------------------------------------------
step_00_preflight() {
  local step="00_preflight"; step_done "$step" && return
  require_root; abort_if_placeholder_domain
  info "Starting Metabase secure bootstrap v$VERSION_TAG — log: $LOG_FILE"
  bootstrap_packages
  mark_done "$step" "Preflight OK"
}

#-------------------------------------------------------------------------------------
# STEP 10: Non-root sudo user
#-------------------------------------------------------------------------------------
step_10_user() {
  local step="10_user"; step_done "$step" && return
  if [[ "$CREATE_NEW_USER" == "true" ]]; then
    if id -u "$NEW_USER" >/dev/null 2>&1; then
      success "User $NEW_USER already exists"
    else
      info "Creating $NEW_USER and adding to sudo"
      adduser --disabled-password --gecos "" "$NEW_USER"
      usermod -aG sudo "$NEW_USER"
      usermod -aG docker "$NEW_USER" 2>/dev/null || true
    fi
    if [[ -n "$NEW_USER_SSH_PUBLIC_KEY" ]]; then
      local ssh_dir="/home/$NEW_USER/.ssh"
      mkdir -p "$ssh_dir"; chmod 700 "$ssh_dir"; chown "$NEW_USER:$NEW_USER" "$ssh_dir"
      echo "$NEW_USER_SSH_PUBLIC_KEY" > "$ssh_dir/authorized_keys"
      chmod 600 "$ssh_dir/authorized_keys"; chown "$NEW_USER:$NEW_USER" "$ssh_dir/authorized_keys"
    else
      warn "NEW_USER_SSH_PUBLIC_KEY is empty — add your key before disabling password auth."
    fi
  else
    info "CREATE_NEW_USER=false — skipping user creation"
  fi
  mark_done "$step" "User step complete"
}

#-------------------------------------------------------------------------------------
# STEP 20: Updates + unattended-upgrades
#-------------------------------------------------------------------------------------
step_20_updates() {
  local step="20_updates"; step_done "$step" && return
  info "Updating packages and enabling unattended-upgrades"
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y
  apt-get -o Dpkg::Options::=--force-confdef -o Dpkg::Options::=--force-confold dist-upgrade -y
  cat >/etc/apt/apt.conf.d/20auto-upgrades <<'EOF'
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
APT::Periodic::AutocleanInterval "7";
EOF
  apt-get install -y unattended-upgrades
  if [[ -f /var/run/reboot-required ]]; then
    warn "Reboot required after upgrades (will be scheduled)."
    touch "$STATE_DIR/reboot_required"
  fi
  apt-get autoremove -y
  mark_done "$step" "System updated"
}

#-------------------------------------------------------------------------------------
# STEP 30: UFW firewall
#-------------------------------------------------------------------------------------
step_30_ufw() {
  local step="30_ufw"; step_done "$step" && return
  info "Configuring UFW"
  ufw --force reset || true
  ufw default deny incoming
  ufw default allow outgoing
  ufw allow 80/tcp
  ufw allow 443/tcp
  ufw allow 22/tcp
  if [[ "$SSH_PORT" -ne 22 ]]; then ufw allow "$SSH_PORT"/tcp; fi
  ufw --force enable
  local port_list="22"
  if [[ "$SSH_PORT" -ne 22 ]]; then port_list+=",$SSH_PORT"; fi
  mark_done "$step" "UFW enabled (80,443,${port_list})"
}

#-------------------------------------------------------------------------------------
# STEP 40: SSH hardening (safe two-stage migration)
#-------------------------------------------------------------------------------------
step_40_ssh() {
  local step="40_ssh"; step_done "$step" && return
  info "Hardening sshd"
  local cfg="/etc/ssh/sshd_config" bak="/etc/ssh/sshd_config.pre-mb-bootstrap"
  [[ -f "$bak" ]] || cp "$cfg" "$bak"

  declare -A opts=(
    ["PasswordAuthentication"]=$([[ "$DISABLE_PASSWORD_AUTH" == "true" ]] && echo no || echo yes)
    ["PermitRootLogin"]=$([[ "$DISABLE_ROOT_SSH" == "true" ]] && echo no || echo prohibit-password)
    ["PubkeyAuthentication"]="yes"
    ["ChallengeResponseAuthentication"]="no"
    ["UsePAM"]="yes"
    ["ClientAliveInterval"]="300"
    ["ClientAliveCountMax"]="2"
    ["X11Forwarding"]="no"
    ["PermitEmptyPasswords"]="no"
    ["LoginGraceTime"]="30"
    ["MaxAuthTries"]="3"
  )
  for k in "${!opts[@]}"; do
    if grep -qE "^\s*${k}\b" "$cfg"; then sed -i "s/^\s*${k}.*/${k} ${opts[$k]}/" "$cfg"; else echo "${k} ${opts[$k]}" >> "$cfg"; fi
  done
  if ! grep -qE '^\s*Port\s+22\b' "$cfg"; then echo "Port 22" >> "$cfg"; fi
  if [[ "$SSH_PORT" -ne 22 ]]; then
    grep -qE '^\s*Port\s+'"$SSH_PORT"'\b' "$cfg" || echo "Port $SSH_PORT" >> "$cfg"
  fi
  sshd -t && { systemctl reload ssh || systemctl reload sshd || true; }
  local ssh_ports="22"; if [[ "$SSH_PORT" -ne 22 ]]; then ssh_ports+=",$SSH_PORT"; fi
  success "sshd reloaded on ports: ${ssh_ports}"
  if [[ "$CLOSE_PORT_22_AFTER_MIGRATION" == "true" && "$SSH_PORT" -ne 22 ]]; then
    sed -i '/^\s*Port\s\+22\b/d' "$cfg"; sshd -t && systemctl reload sshd; ufw delete allow 22/tcp || true
    success "Port 22 removed (config + UFW)"
  else
    warn "Port 22 kept open for safety. Set CLOSE_PORT_22_AFTER_MIGRATION=true to remove it on next run."
  fi
  mark_done "$step" "SSH hardened"
}

#-------------------------------------------------------------------------------------
# STEP 50: Fail2ban
#-------------------------------------------------------------------------------------
step_50_fail2ban() {
  local step="50_fail2ban"; step_done "$step" && return
  info "Configuring Fail2ban"
  mkdir -p /etc/fail2ban/jail.d
  cat >/etc/fail2ban/jail.d/sshd.local <<EOF
[sshd]
enabled = true
mode    = aggressive
port    = $SSH_PORT
maxretry = 4
findtime = 15m
bantime  = 24h
EOF
  systemctl enable --now fail2ban
  mark_done "$step" "Fail2ban enabled"
}

#-------------------------------------------------------------------------------------
# STEP 60: AppArmor
#-------------------------------------------------------------------------------------
step_60_apparmor() {
  local step="60_apparmor"; step_done "$step" && return
  if command -v aa-status >/dev/null 2>&1; then
    if aa-status | grep -q "profiles are in enforce mode"; then success "AppArmor active"; else
      warn "AppArmor not enforcing — enabling at boot"
      if ! grep -q 'apparmor=1' /etc/default/grub; then
        sed -i 's/GRUB_CMDLINE_LINUX="\(.*\)"/GRUB_CMDLINE_LINUX="\1 apparmor=1 security=apparmor"/' /etc/default/grub || true
      fi
      update-grub || true
      touch "$STATE_DIR/reboot_required"
    fi
  fi
  mark_done "$step" "AppArmor checked"
}

#-------------------------------------------------------------------------------------
# STEP 70: Docker Engine + Compose
#-------------------------------------------------------------------------------------
step_70_docker() {
  local step="70_docker"; step_done "$step" && return
  info "Installing Docker Engine"
  if ! command -v docker >/dev/null 2>&1; then
    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo $VERSION_CODENAME) stable" \
      | tee /etc/apt/sources.list.d/docker.list >/dev/null
    apt-get update -y
    DEBIAN_FRONTEND=noninteractive apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    systemctl enable --now docker
  else
    success "Docker already present"
  fi
  if [[ "$CREATE_NEW_USER" == "true" ]] && id -u "$NEW_USER" >/dev/null 2>&1; then usermod -aG docker "$NEW_USER" || true; fi
  mark_done "$step" "Docker ready"
}

#-------------------------------------------------------------------------------------
# STEP 80: CrowdSec (optional)
#-------------------------------------------------------------------------------------
step_80_crowdsec() {
  local step="80_crowdsec"; step_done "$step" && return
  if [[ "$CROWDSEC_ENABLE" == "true" ]]; then
    info "Installing CrowdSec + firewall bouncer"
    if ! command -v crowdsec >/dev/null 2>&1; then
      curl -s https://packagecloud.io/install/repositories/crowdsec/crowdsec/script.deb.sh | bash
      DEBIAN_FRONTEND=noninteractive apt-get install -y crowdsec crowdsec-firewall-bouncer-iptables
      systemctl enable --now crowdsec crowdsec-firewall-bouncer
    else
      success "CrowdSec already installed"
    fi
  else
    info "CrowdSec disabled — skipping"
  fi
  mark_done "$step" "CrowdSec step complete"
}

#-------------------------------------------------------------------------------------
# STEP 90: Stack files (Metabase + Postgres + Caddy)
#-------------------------------------------------------------------------------------
step_90_stack() {
  local step="90_stack"; step_done "$step" && return
  mkdir -p "$MB_DATA_DIR" "$MB_DATA_DIR/postgres" "$MB_DATA_DIR/caddy"

  # Secrets
  if [[ -z "$DB_PASSWORD" ]]; then DB_PASSWORD=$(random_base64 24); info "Generated DB password"; fi

  # Basic Auth password — generate if placeholder/empty and store to file
  local BASIC_AUTH_HASH="" GENERATE_NOTE=""
  if [[ "$BASIC_AUTH_ENABLE" == "true" ]]; then
    if [[ -z "$BASIC_AUTH_PASSWORD" || "$BASIC_AUTH_PASSWORD" == "changeMe" ]]; then
      BASIC_AUTH_PASSWORD=$(random_base64 18)
      GENERATE_NOTE="(generated)"
      umask 077; echo -e "user: $BASIC_AUTH_USER\npassword: $BASIC_AUTH_PASSWORD" > "$BASIC_AUTH_SECRETS_FILE" || true
      info "Generated Basic Auth password; saved to $BASIC_AUTH_SECRETS_FILE"
    fi
    BASIC_AUTH_HASH=$(docker run --rm caddy:2-alpine caddy hash-password --plaintext "$BASIC_AUTH_PASSWORD")
  fi

  # docker-compose.yml
  cat >"$MB_DATA_DIR/docker-compose.yml" <<'YML'
services:
  postgres:
    image: postgres:16-alpine
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 10
    volumes:
      - ./postgres:/var/lib/postgresql/data

  metabase:
    image: metabase/metabase:${MB_VERSION}
    restart: unless-stopped
    depends_on:
      - postgres
    environment:
      - TZ=${TZ}
      - MB_DB_TYPE=postgres
      - MB_DB_DBNAME=${DB_NAME}
      - MB_DB_PORT=5432
      - MB_DB_USER=${DB_USER}
      - MB_DB_PASS=${DB_PASSWORD}
      - MB_DB_HOST=postgres
      - MB_SITE_URL=${SITE_URL}
      - JAVA_TOOL_OPTIONS=-Xms512m -Xmx1024m
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/api/health"]
      interval: 15s
      timeout: 5s
      retries: 20

  caddy:
    image: caddy:2-alpine
    restart: unless-stopped
    depends_on:
      - metabase
    ports:
      - "80:80"
      - "443:443"
    environment:
      DOMAIN: ${DOMAIN}
      EMAIL: ${EMAIL}
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data
      - caddy_config:/config

volumes:
  caddy_data:
  caddy_config:
YML

  # Caddyfile — embed Basic Auth hash directly; use modern directive `basic_auth`
  if [[ "$BASIC_AUTH_ENABLE" == "true" ]]; then
    cat >"$MB_DATA_DIR/caddy/Caddyfile" <<CADDY
{\$DOMAIN} {
  encode zstd gzip
  tls {\$EMAIL}

  header {
    Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
    X-Frame-Options "DENY"
    X-Content-Type-Options "nosniff"
    Referrer-Policy "strict-origin-when-cross-origin"
    Permissions-Policy "geolocation=(), microphone=(), camera=()"
  }

  basic_auth /* {
    ${BASIC_AUTH_USER} ${BASIC_AUTH_HASH}
  }

  reverse_proxy metabase:3000
}
CADDY
  else
    cat >"$MB_DATA_DIR/caddy/Caddyfile" <<'CADDY'
{$DOMAIN} {
  encode zstd gzip
  tls {$EMAIL}
  header {
    Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
    X-Frame-Options "DENY"
    X-Content-Type-Options "nosniff"
    Referrer-Policy "strict-origin-when-cross-origin"
    Permissions-Policy "geolocation=(), microphone=(), camera=()"
  }
  reverse_proxy metabase:3000
}
CADDY
  fi

  # Env file (for compose & reference)
  cat >"$MB_DATA_DIR/.env" <<ENV
DOMAIN=${DOMAIN}
EMAIL=${EMAIL}
DB_NAME=${DB_NAME}
DB_USER=${DB_USER}
DB_PASSWORD=${DB_PASSWORD}
MB_VERSION=${MB_VERSION}
TZ=${TZ}
SITE_URL=${SITE_URL}
BASIC_AUTH_ENABLE=${BASIC_AUTH_ENABLE}
BASIC_AUTH_USER=${BASIC_AUTH_USER}
# BASIC_AUTH_PASSWORD ${GENERATE_NOTE}
ENV

  mark_done "$step" "Stack files prepared (Basic Auth ${BASIC_AUTH_ENABLE})"
}

#-------------------------------------------------------------------------------------
# STEP 100: Launch stack
#-------------------------------------------------------------------------------------
step_100_launch() {
  local step="100_launch"; step_done "$step" && return
  info "Launching compose stack"
  (cd "$MB_DATA_DIR" && docker compose --env-file ./.env up -d)
  sleep 3
  (cd "$MB_DATA_DIR" && docker compose ps || true)
  mark_done "$step" "Stack launched — Caddy will request certificates automatically"
}

#-------------------------------------------------------------------------------------
# STEP 110: Summary
#-------------------------------------------------------------------------------------
step_110_summary() {
  local step="110_summary"; step_done "$step" && return
  check_dns || true
  info "\n=== INSTALL SUMMARY ==="
  info "Domain:      $DOMAIN"
  info "Email:       $EMAIL"
  local ssh_ports="22"; if [[ "$SSH_PORT" -ne 22 ]]; then ssh_ports+=",$SSH_PORT"; fi
  info "SSH ports:   ${ssh_ports} (22 kept unless CLOSE_PORT_22_AFTER_MIGRATION=true)"
  info "Data dir:    $MB_DATA_DIR"
  info "Stack:       Metabase + PostgreSQL + Caddy"
  info "Basic Auth:  $BASIC_AUTH_ENABLE (user: $BASIC_AUTH_USER)"
  if [[ "$BASIC_AUTH_ENABLE" == "true" && -f "$BASIC_AUTH_SECRETS_FILE" ]]; then
    info "Basic Auth password saved at $BASIC_AUTH_SECRETS_FILE (root-only)"
  fi
  info "CrowdSec:    $CROWDSEC_ENABLE"
  info "Open after TLS: https://$DOMAIN/"
  info "Logs: cd $MB_DATA_DIR && docker compose logs -f caddy metabase"
  mark_done "$step" "Summary printed"
}

#-------------------------------------------------------------------------------------
# REBOOT HANDLER — ask user to confirm SSH access before reboot
#-------------------------------------------------------------------------------------
confirm_before_reboot() {
  local port msg
  [[ -n "$SSH_CONFIRM_PORT" ]] && port="$SSH_CONFIRM_PORT" || port="$SSH_PORT"
  msg="Before rebooting, open a NEW terminal and confirm you can SSH back in:\n\n"
  msg+="  ssh -p $port <user>@<server_ip_or_domain>\n\n"
  msg+="If that works, type 'REBOOT' exactly to proceed. Type anything else to skip.\n"
  echo -e "$msg"
  read -r -p "Type REBOOT to proceed with reboot now: " choice || true
  if [[ "$choice" == "REBOOT" ]]; then
    return 0
  else
    warn "Reboot skipped by user. You can reboot later and re-run the script."
    return 1
  fi
}

#-------------------------------------------------------------------------------------
# MAIN
#-------------------------------------------------------------------------------------
main() {
  trap 'rc=$?; fail "An error occurred (exit $rc). See $LOG_FILE."; exit $rc' ERR
  step_00_preflight
  step_10_user
  step_20_updates
  step_30_ufw
  step_40_ssh
  step_50_fail2ban
  step_60_apparmor
  step_70_docker
  step_80_crowdsec
  step_90_stack

  if [[ -f "$STATE_DIR/reboot_required" ]]; then
    warn "Reboot required to apply kernel/AppArmor changes."
    local do_reboot=false
    if [[ "$AUTO_REBOOT" == "true" ]]; then
      info "AUTO_REBOOT=true — proceeding without prompt."; do_reboot=true
    elif [[ "$REQUIRE_SSH_CONFIRM_BEFORE_REBOOT" == "true" ]]; then
      if confirm_before_reboot; then do_reboot=true; fi
    else
      do_reboot=true
    fi
    if [[ "$do_reboot" == true ]]; then
      rm -f "$STATE_DIR/reboot_required"
      cat >/etc/systemd/system/mb-bootstrap-resume.service <<SVC
[Unit]
Description=Metabase bootstrap resume
After=network-online.target docker.service
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/bin/env bash "${BASH_SOURCE[0]}"
RemainAfterExit=no

[Install]
WantedBy=multi-user.target
SVC
      systemctl daemon-reload
      systemctl enable mb-bootstrap-resume.service
      sleep 2
      reboot
    fi
  fi

  step_100_launch
  step_110_summary

  if systemctl is-enabled mb-bootstrap-resume.service >/dev/null 2>&1; then
    systemctl disable mb-bootstrap-resume.service || true
    rm -f /etc/systemd/system/mb-bootstrap-resume.service
    systemctl daemon-reload || true
  fi

  success "All done!"
}

main "$@"
